!DOCTYPE html>



<html lang="en">





<head>


    <meta charset="UTF-8">


    <title>Catan Multiplayer</title>


    <style>
        body {


            font-family: Arial, sans-serif;


            margin: 20px;


        }





        #log {


            border: 1px solid #ccc;


            padding: 10px;


            height: 200px;


            overflow-y: scroll;


        }





        button {


            margin: 5px;


        }





        #players {


            margin-top: 10px;


        }





        .action-block {


            margin: 5px 0;


        }





        canvas {


            background: white;


            border: 2px solid #333;


            margin-top: 20px;


        }
    </style>


</head>





<body>


    <h1>Catan Multiplayer (Demo)</h1>





    <div>


        <button id="createBtn">Create Game</button>


        <input type="text" id="gameIdInput" placeholder="Enter game ID">


        <button id="joinBtn">Join Game</button>


        <button id="startBtn">Start Game</button>


    </div>





    <h3>Game Info</h3>


    <p>Game ID: <span id="gameId">-</span></p>


    <p>Player ID: <span id="playerId">-</span></p>





    <h3>Players</h3>


    <ul id="players"></ul>





    <h3>Log</h3>


    <div id="log"></div>





    <h3>Actions</h3>


    <div id="actions"></div>





    <h3>Board</h3>


    <canvas id="board" width="900" height="800"></canvas>





    <script>


        let gameId = null;


        let playerId = null;


        let ws = null;





        const logDiv = document.getElementById("log");


        const playersUl = document.getElementById("players");





        function log(msg) {


            logDiv.innerHTML += `<div>${msg}</div>`;


            logDiv.scrollTop = logDiv.scrollHeight;


        }





        // === BACKEND INTEGRATION ===


        document.getElementById("createBtn").onclick = async () => {


            const res = await fetch("http://localhost:8000/create", { method: "POST" });


            const data = await res.json();


            gameId = data.game_id;


            playerId = data.player_id;


            document.getElementById("gameId").innerText = gameId;


            document.getElementById("playerId").innerText = playerId;


            log(`Created game ${gameId}, you are Player ${playerId}`);


            connectWS();


        };





        document.getElementById("joinBtn").onclick = async () => {


            const id = document.getElementById("gameIdInput").value;


            if (!id) return alert("Enter game ID");


            const res = await fetch("http://localhost:8000/join", {


                method: "POST",


                headers: { "Content-Type": "application/json" },


                body: JSON.stringify({ game_id: parseInt(id) })


            });


            const data = await res.json();


            if (data.message) {


                log("Error: " + data.message);


                return;


            }


            gameId = data.game_id;


            playerId = data.player_id;


            document.getElementById("gameId").innerText = gameId;


            document.getElementById("playerId").innerText = playerId;


            log(`Joined game ${gameId}, you are Player ${playerId}`);


            connectWS();


        };





        document.getElementById("startBtn").onclick = async () => {


            if (!gameId) return alert("No game ID set");


            const res = await fetch(`http://localhost:8000/game/${gameId}/start`, {


                method: "POST",


                headers: { "Content-Type": "application/json" },


                body: JSON.stringify({ game_id: gameId })


            });


            const data = await res.json();


            log("Start Game response: " + JSON.stringify(data));


        };





        function connectWS() {


            ws = new WebSocket(`ws://localhost:8000/ws/${gameId}/${playerId}`);


            ws.onopen = () => log("Connected to WebSocket");


            ws.onmessage = (event) => log("Message: " + event.data);


            ws.onclose = () => log("WebSocket closed");


        }





        // === HELPER FUNCTIONS ===


        function parseResources(str) {


            const parts = str.trim().split(/\s+/);


            const res = {};


            parts.forEach(p => {


                const [key, val] = p.split(":");


                if (key && val) res[key] = parseInt(val);


            });


            return res;


        }





        // === ACTION BUTTONS ===


        const ACTIONS = [


            { label: "Roll Dice", build: () => ({ type: "roll_dice" }) },


            { label: "End Turn", build: () => ({ type: "end_turn" }) },


            { label: "Discard Resources", build: (v) => ({ type: "discard_resources", resources: parseResources(v) }) },


            { label: "Move Robber", build: (v) => ({ type: "move_robber", target_tile: parseInt(v) }) },


            { label: "Place Road", build: (v) => ({ type: "place_road", edge_id: parseInt(v) }) },


            { label: "Place Settlement", build: (v) => ({ type: "place_settlement", vertex_id: parseInt(v) }) },


            { label: "Place City", build: (v) => ({ type: "place_city", vertex_id: parseInt(v) }) },


            { label: "Buy Development Card", build: () => ({ type: "buy_development_card" }) },


            {


                label: "Play Knight", build: (v) => {


                    const [tile, victim] = v.split(" ");


                    return { type: "play_knight", target_tile: parseInt(tile), victim_id: parseInt(victim) };


                }


            },


            {


                label: "Play Road Building", build: (v) => {


                    const ids = v.split(" ").map(x => parseInt(x)).filter(Boolean);


                    return { type: "play_road_building", edge_ids: ids };


                }


            },


            {


                label: "Play Year of Plenty", build: (v) => {


                    const res = v.split(" ").filter(Boolean);


                    return { type: "play_year_of_plenty", resources: res };


                }


            },


            { label: "Play Monopoly", build: (v) => ({ type: "play_monopoly", resource: v.trim() }) },


            {


                label: "Propose Trade", build: (v) => {


                    const [tid, offerStr, requestStr] = v.split("|").map(s => s.trim());


                    return { type: "propose_trade", trader_id: parseInt(tid), offer: parseResources(offerStr), request: parseResources(requestStr) };


                }


            },


            { label: "Accept Trade", build: (v) => ({ type: "accept_trade", trader_id: parseInt(v) }) },


            { label: "Decline Trade", build: (v) => ({ type: "decline_trade", trader_id: parseInt(v) }) },


            {


                label: "Make Trade", build: (v) => {


                    const [ids, offerStr, requestStr] = v.split("|").map(s => s.trim());


                    const [id1, id2] = ids.split(" ").map(x => parseInt(x));


                    return { type: "make_trade", trader_1_id: id1, trader_2_id: id2, offer: parseResources(offerStr), request: parseResources(requestStr) };


                }


            },


            {


                label: "Bank Trade", build: (v) => {


                    const [offerStr, requestStr] = v.split("|").map(s => s.trim());


                    return { type: "bank_trade", offer: parseResources(offerStr), request: parseResources(requestStr) };


                }


            },


        ];





        const actionsDiv = document.getElementById("actions");


        ACTIONS.forEach((a) => {


            const block = document.createElement("div");


            block.className = "action-block";





            const btn = document.createElement("button");


            btn.textContent = a.label;


            const input = document.createElement("input");


            input.type = "text";


            input.placeholder = "Input";


            if (a.build.length === 0) input.style.display = "none";





            btn.onclick = () => {


                if (!ws) return alert("Not connected");


                try {


                    const payload = a.build(input.value);


                    ws.send(JSON.stringify(payload));


                    log("Sent: " + JSON.stringify(payload));


                } catch (err) {


                    log("Error: " + err.message);


                }


            };





            block.appendChild(btn);


            block.appendChild(input);


            actionsDiv.appendChild(block);


        });





        // === BOARD DRAWING ===


        const canvas = document.getElementById("board");


        const ctx = canvas.getContext("2d");





        const colors = {


            "Brick": "#d2691e",


            "Ore": "#808080",


            "Wheat": "#f0e68c",


            "Wood": "#228b22",


            "Sheep": "#98fb98",


            "Desert": "#edc9af"


        };





        const tiles = Array.from({ length: 19 }, (_, i) => ({


            id: i,


            resource: ["Brick", "Ore", "Wheat", "Wood", "Sheep", "Desert"][i % 6],


            number: i + 2,


            robber: i === 10


        }));





        function drawHex(x, y, size, fill, text, robber) {


            ctx.beginPath();


            for (let i = 0; i < 6; i++) {


                const angle = Math.PI / 3 * i + Math.PI / 6;


                const px = x + size * Math.cos(angle);


                const py = y + size * Math.sin(angle);


                if (i === 0) ctx.moveTo(px, py);


                else ctx.lineTo(px, py);


            }


            ctx.closePath();


            ctx.fillStyle = fill;


            ctx.fill();


            ctx.stroke();





            ctx.fillStyle = "black";


            ctx.font = "14px Arial";


            ctx.textAlign = "center";


            ctx.textBaseline = "middle";


            ctx.fillText(text, x, y);





            if (robber) {


                ctx.fillStyle = "red";


                ctx.fillText("R", x, y + 18);


            }


        }





        // === proper layout ===


        const layout = [3, 4, 5, 4, 3];


        const size = 55;  // hex radius


        const dx = size * 1.8;     // horizontal spacing


        const dy = Math.sqrt(3) * size * 0.9; // vertical spacing





        let tileIndex = 0;


        let startY = 120;





        // store unique vertices & edges


        let vertices = [];


        let edges = [];





        function findOrAddVertex(x, y) {


            const key = `${Math.round(x)}:${Math.round(y)}`;


            if (!(key in findOrAddVertex.map)) {


                const v = { id: vertices.length, x, y };


                vertices.push(v);


                findOrAddVertex.map[key] = v;


            }


            return findOrAddVertex.map[key];


        }


        findOrAddVertex.map = {};





        function findOrAddEdge(v1, v2) {


            // ensure ordering to dedup


            const key = v1.id < v2.id ? `${v1.id}-${v2.id}` : `${v2.id}-${v1.id}`;


            if (!(key in findOrAddEdge.map)) {


                const e = { id: edges.length, v1, v2 };


                edges.push(e);


                findOrAddEdge.map[key] = e;


            }


            return findOrAddEdge.map[key];


        }


        findOrAddEdge.map = {};





        // draw tiles


        layout.forEach((count, row) => {


            let offsetX = canvas.width / 2 - (count - 1) * dx / 2;


            for (let col = 0; col < count; col++) {


                if (tileIndex >= tiles.length) continue;


                const x = offsetX + col * dx;


                const y = startY + row * dy;


                const t = tiles[tileIndex];


                drawHex(x, y, size, colors[t.resource], t.number ?? "", t.robber);





                // collect vertices/edges


                let hexVertices = [];


                for (let i = 0; i < 6; i++) {


                    const angle = Math.PI / 3 * i + Math.PI / 6;


                    const vx = x + size * Math.cos(angle);


                    const vy = y + size * Math.sin(angle);


                    hexVertices.push(findOrAddVertex(vx, vy));


                }


                for (let i = 0; i < 6; i++) {


                    const v1 = hexVertices[i];


                    const v2 = hexVertices[(i + 1) % 6];


                    findOrAddEdge(v1, v2);


                }





                tileIndex++;


            }


        });





        // draw vertices


        ctx.fillStyle = "blue";


        vertices.forEach(v => {


            ctx.beginPath();


            ctx.arc(v.x, v.y, 4, 0, Math.PI * 2);


            ctx.fill();


            ctx.fillText(v.id, v.x, v.y - 10);


        });





        // draw edges


        ctx.strokeStyle = "black";


        edges.forEach(e => {


            ctx.beginPath();


            ctx.moveTo(e.v1.x, e.v1.y);


            ctx.lineTo(e.v2.x, e.v2.y);


            ctx.stroke();


            const mx = (e.v1.x + e.v2.x) / 2;


            const my = (e.v1.y + e.v2.y) / 2;


            ctx.fillText(e.id, mx, my);


        });








    </script>


</body>





</html>